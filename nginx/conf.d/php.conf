# HTTP服务器(2021年5月18日 08:02:08 这个报错了！！)
#http {
  #自动索引，列出所有索引项
  #autoindex on;

  #默认编码
  #charset utf-8;
#}
server {
  # 监听80端口，用于HTTP协议
  listen 80;

  # 首页指向
  index index.php index.html;

  # 定义适用localhost进行访问
  server_name localhost;

  # 日志文件记录地址
  error_log  /var/log/nginx/error.log;
  access_log /var/log/nginx/access.log;

  # 指向webapp的目录地址
  root /api;
  # 首页指向
  index index.php index.html index.htm default.php default.htm default.html;

  #添加响应头 https
  add_header Content-Security-Policy "upgrade-insecure-requests'";
  # 允许跨域
  add_header Access-Control-Allow-Origin *;

  # 将所有的请求都rewrite成index.php的形式
  # 反向代理的地址
  location / {
    # try_files 会尝试列出的文件并设置内部文件指向
    # 比如说 localhost/test  $uri=test 如果存在/$root/test的文件，那么就发送给客户
    # 如果上面找不到，那就找有没有名为/$root/test的目录，如果还没有则尝试最后一项
    # 尝试发起/index.php的内部请求，而这个就会被下面的php{}块进行管理
    # /api/get?id=1
    # $is_args 是否携带了queryString，携带为'?' 没有就为''
    # $query_string=$args = 'id=1'
    # last url重写后，直接发起新请求，进入server块，重新尝试location匹配
    # break 直接使用当前资源，完成请求，rul不变
    # redirect 302临时重定向，地址栏显示重定向的，爬虫不会更新url
    # permanent 301永久重定向，地址栏显示重定向的，爬虫更新url
    try_files $uri $uri/ /index.php$is_args$query_string last;
    # try_files $uri $uri/ @api;
  }

  # 弃用版本，等后面学会了再说吧
  # location @api {
  #   rewrite /api/(.*)$ /api/index.php?/$1 last;
  # }

  # 所有重写的url 以及以.php结尾的URI，都由location ~ .php{}块进行管理
  location ~ \.php$ {
    try_files $uri =404;
    # fastcgi_split_path_info作用
    # 将$1赋值给 $fastcgi_script_name
    # 将$2赋值给 $fastcgi_path_info
    fastcgi_split_path_info ^(.+?\.php)(/.+)$;
    fastcgi_pass php:9000;
    fastcgi_index index.php;
    include fastcgi_params;

    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_param PATH_INFO $fastcgi_path_info;
  }

  # Nginx状态的地址
  location /NginxStatus {
      stub_status on;
      access_log    on;
      auth_basic "NginxStatus";
      auth_basic_user_file conf/htpasswd;
  }
}